"""Recommendation adherence tracking.

Records daily recommendations, evaluates whether they were followed,
and calculates the impact on recovery outcomes.
"""

import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from statistics import mean

from sqlalchemy.orm import Session

from whoopdata.models.models import Recommendation, RecommendationOutcome, Recovery, Sleep
from whoopdata.schemas.daily import DailyAction

logger = logging.getLogger(__name__)


class AdherenceTracker:
    """Track recommendation adherence and outcome correlation."""

    def __init__(self, db: Session):
        self.db = db

    def record_recommendations(self, date: datetime, actions: List[DailyAction]) -> List[int]:
        """Store daily recommendations for later adherence checking.

        Args:
            date: Date the recommendations are for
            actions: List of daily actions generated by the engine

        Returns:
            List of recommendation IDs created
        """
        ids = []
        for action in actions:
            # Extract target metric and value from sleep/training actions
            target_metric, target_value = self._extract_target(action)

            rec = Recommendation(
                date=date,
                action_text=action.action,
                category=action.category,
                target_metric=target_metric,
                target_value=target_value,
            )
            self.db.add(rec)
            self.db.flush()
            ids.append(rec.id)

        self.db.commit()
        return ids

    def evaluate_adherence(self, date: datetime) -> List[Dict]:
        """Evaluate whether yesterday's recommendations were followed.

        Checks actual sleep/recovery data against recommendation targets.

        Args:
            date: Date to evaluate (checks recommendations from this date)

        Returns:
            List of adherence evaluation results
        """
        recommendations = (
            self.db.query(Recommendation)
            .filter(Recommendation.date >= date, Recommendation.date < date + timedelta(days=1))
            .all()
        )

        if not recommendations:
            return []

        # Get actual data for the next day (outcome day)
        next_day = date + timedelta(days=1)
        actual_data = self._get_actual_data(next_day)

        results = []
        for rec in recommendations:
            outcome = self._check_recommendation(rec, actual_data)
            if outcome:
                self.db.add(outcome)
                results.append({
                    "recommendation": rec.action_text,
                    "category": rec.category,
                    "followed": outcome.followed,
                    "actual_value": outcome.actual_value,
                    "target_value": rec.target_value,
                    "recovery_score": outcome.recovery_score,
                })

        self.db.commit()
        return results

    def get_adherence_summary(self, days: int = 7) -> Dict:
        """Get adherence rate and outcome correlation over a period.

        Args:
            days: Number of days to look back

        Returns:
            Summary with adherence rate and recovery comparison
        """
        since = datetime.utcnow() - timedelta(days=days)

        outcomes = (
            self.db.query(RecommendationOutcome)
            .filter(RecommendationOutcome.recorded_at >= since)
            .all()
        )

        if not outcomes:
            return {
                "period_days": days,
                "total_recommendations": 0,
                "adherence_rate": None,
                "recovery_when_followed": None,
                "recovery_when_not_followed": None,
                "message": "No recommendations tracked yet.",
            }

        total = len(outcomes)
        followed = [o for o in outcomes if o.followed]
        not_followed = [o for o in outcomes if not o.followed]

        adherence_rate = len(followed) / total * 100

        recovery_followed = (
            mean([o.recovery_score for o in followed if o.recovery_score is not None])
            if followed and any(o.recovery_score for o in followed)
            else None
        )
        recovery_not_followed = (
            mean([o.recovery_score for o in not_followed if o.recovery_score is not None])
            if not_followed and any(o.recovery_score for o in not_followed)
            else None
        )

        message = self._build_adherence_message(
            adherence_rate, recovery_followed, recovery_not_followed, total
        )

        return {
            "period_days": days,
            "total_recommendations": total,
            "followed_count": len(followed),
            "adherence_rate": round(adherence_rate, 1),
            "recovery_when_followed": round(recovery_followed, 1) if recovery_followed else None,
            "recovery_when_not_followed": (
                round(recovery_not_followed, 1) if recovery_not_followed else None
            ),
            "message": message,
        }

    def _extract_target(self, action: DailyAction) -> tuple:
        """Extract a measurable target from an action."""
        if action.category == "sleep":
            # Try to extract sleep hour target from action text
            import re

            match = re.search(r"(\d+\.?\d*)\+?\s*hours?", action.action)
            if match:
                return "sleep_hours", float(match.group(1))
            return "sleep_hours", None

        if action.category == "training":
            return "strain", None

        return None, None

    def _get_actual_data(self, date: datetime) -> Dict:
        """Get actual health metrics for a specific date."""
        # Find recovery for this date
        recovery = (
            self.db.query(Recovery)
            .filter(
                Recovery.created_at >= date,
                Recovery.created_at < date + timedelta(days=1),
            )
            .first()
        )

        # Find sleep ending on this date
        sleep = (
            self.db.query(Sleep)
            .filter(Sleep.end >= date, Sleep.end < date + timedelta(days=1))
            .first()
        )

        data = {"recovery_score": None, "sleep_hours": None}

        if recovery:
            data["recovery_score"] = recovery.recovery_score

        if sleep and sleep.total_time_in_bed_time_milli and sleep.total_awake_time_milli:
            data["sleep_hours"] = (
                sleep.total_time_in_bed_time_milli - sleep.total_awake_time_milli
            ) / 3600000

        return data

    def _check_recommendation(
        self, rec: Recommendation, actual: Dict
    ) -> Optional[RecommendationOutcome]:
        """Check if a single recommendation was followed."""
        if not rec.target_metric:
            return None

        actual_value = actual.get(rec.target_metric)
        if actual_value is None:
            return None

        followed = False
        delta = None

        if rec.target_value is not None:
            delta = actual_value - rec.target_value
            # For sleep: followed if within 0.5h of target
            if rec.target_metric == "sleep_hours":
                followed = actual_value >= rec.target_value - 0.5
            else:
                followed = delta >= 0

        return RecommendationOutcome(
            recommendation_id=rec.id,
            actual_metric=rec.target_metric,
            actual_value=actual_value,
            followed=followed,
            outcome_delta=delta,
            recovery_score=actual.get("recovery_score"),
        )

    def _build_adherence_message(
        self,
        rate: float,
        recovery_followed: Optional[float],
        recovery_not_followed: Optional[float],
        total: int,
    ) -> str:
        """Build a human-readable adherence summary."""
        parts = [f"You followed {rate:.0f}% of recommendations ({total} total)."]

        if recovery_followed is not None and recovery_not_followed is not None:
            diff = recovery_followed - recovery_not_followed
            if diff > 2:
                parts.append(
                    f"Recovery averaged {recovery_followed:.0f}% when followed "
                    f"vs {recovery_not_followed:.0f}% when not â€” "
                    f"a {diff:.0f}% difference."
                )
            elif diff < -2:
                parts.append(
                    "Interestingly, recovery was similar regardless of adherence. "
                    "Recommendations may need refinement."
                )

        return " ".join(parts)
